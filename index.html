<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=dev            direction: new THREE.Vector3(),
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            canJump: false,
            prevTime: performance.now(),
            speed: 0.8,
            collisionRadius: 0.25  // Further reduced collision radius for better movement through tight spaces, initial-scale=1.0">
    <title>3D Gallery Viewer</title>
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #controlsContainer {
            background-color: #ffffff;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        input[type="file"] {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
        }
        input[type="file"]::file-selector-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #0056b3;
        }
        #loaderInfo {
            font-size: 0.9em;
            color: #555;
        }
        #canvasContainer {
            width: 95%;
            
            height: 75vh;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #e0e0e0;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        #errorMessage {
            color: red;
            margin-top: 10px;
            padding: 10px;
            background-color: #ffebee;
            border: 1px solid #ef9a9a;
            border-radius: 4px;
            display: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    
    <div id="controlsContainer">
        <span id="loaderInfo">Loading model...</span>
    </div>
    <div id="errorMessage"></div>
    <div id="canvasContainer"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // Declare variables in a wider scope
        let scene, camera, renderer, controls, model;
        const canvasContainer = document.getElementById('canvasContainer');
        const fileInput = document.getElementById('glbFile');
        const loaderInfo = document.getElementById('loaderInfo');
        const errorMessage = document.getElementById('errorMessage');            // Simple first-person controls state
        let fpControls = {
            enabled: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            canJump: false,
            prevTime: performance.now(),
            speed: 0.8,
            collisionRadius: 0.3  // Further reduced collision radius for better movement through tight spaces
        };

        // Function to initialize the Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);

            // Camera
            camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 2000);
            camera.position.set(0, 2, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.useLegacyLights = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            canvasContainer.appendChild(renderer.domElement);

            // OrbitControls for camera manipulation (default)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.1;
            controls.maxDistance = 1000;
            controls.target.set(0, 0, 0);
            controls.update();
            // Log camera and target on every change
            controls.addEventListener('change', () => {
                console.log('Camera position:', camera.position.clone(), 'Controls target:', controls.target.clone());
            });

            // First-person controls event listeners
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            canvasContainer.addEventListener('click', () => {
                if (fpControls.enabled) {
                    canvasContainer.requestPointerLock();
                }
            });

            // Add basic lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Start the animation loop
            animate();
        }

        // Function to handle window resize
        function onWindowResize() {
            if (camera && renderer && canvasContainer) {
                const width = canvasContainer.clientWidth;
                const height = canvasContainer.clientHeight;
                if (width > 0 && height > 0) {
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (fpControls.enabled) {
                updateFirstPersonControls();
            } else if (controls) {
                controls.update();
            }
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        // --- First Person Controls Implementation ---
        function enableFirstPersonControls(enable) {
            fpControls.enabled = enable;
            if (enable) {
                controls.enabled = false;
                syncYawPitchToCamera();
                canvasContainer.requestPointerLock();
            } else {
                controls.enabled = true;
                document.exitPointerLock();
            }
        }

        // Ensure yaw/pitch are initialized to match camera direction on first enable
        function syncYawPitchToCamera() {
            // Get direction vector from camera
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            yaw = Math.atan2(-dir.x, -dir.z);
            pitch = Math.asin(dir.y);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    fpControls.moveForward = true; break;
                case 'ArrowDown':
                case 'KeyS':
                    fpControls.moveBackward = true; break;
                case 'ArrowLeft':
                case 'KeyA':
                    fpControls.moveLeft = true; break;
                case 'ArrowRight':
                case 'KeyD':
                    fpControls.moveRight = true; break;
                case 'Escape':
                    enableFirstPersonControls(false); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    fpControls.moveForward = false; break;
                case 'ArrowDown':
                case 'KeyS':
                    fpControls.moveBackward = false; break;
                case 'ArrowLeft':
                case 'KeyA':
                    fpControls.moveLeft = false; break;
                case 'ArrowRight':
                case 'KeyD':
                    fpControls.moveRight = false; break;
            }
        }

        // Mouse look
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvasContainer && fpControls.enabled) {
                document.addEventListener('mousemove', onMouseMove, false);
            } else {
                document.removeEventListener('mousemove', onMouseMove, false);
            }
        });

        let yaw = 0, pitch = 0;
        function onMouseMove(event) {
            if (!fpControls.enabled) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            yaw -= movementX * 0.002;  // Inverted horizontal mouse movement
            pitch -= movementY * 0.002; // Keep this as -= for natural vertical look
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        }

        function updateFirstPersonControls() {
            const time = performance.now();
            const delta = (time - fpControls.prevTime) / 1000;
            fpControls.prevTime = time;

            // Get forward direction from camera (ignore pitch)
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            // Calculate right vector from forward
            const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

            // Calculate movement vector based on input
            const move = new THREE.Vector3();
            
            // Forward/back movement
            if (fpControls.moveForward) move.addScaledVector(forward, fpControls.speed * delta);
            if (fpControls.moveBackward) move.addScaledVector(forward, -fpControls.speed * delta);
            
            // Left/right movement
            if (fpControls.moveLeft) move.addScaledVector(right, -fpControls.speed * delta);
            if (fpControls.moveRight) move.addScaledVector(right, fpControls.speed * delta);

            // Apply camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;

            // Calculate new position with collision detection
            let newPos = camera.position.clone().add(move);

            // Enhanced collision detection for curved walls
            if (model) {
                const cameraBox = new THREE.Box3();
                const cameraSize = fpControls.collisionRadius * 2;
                cameraBox.setFromCenterAndSize(newPos, new THREE.Vector3(cameraSize, cameraSize, cameraSize));

                let collision = false;
                let collisionCount = 0;
                let collidingMeshes = [];

                model.traverse((node) => {
                    if (node.isMesh) {
                        // Only check collision with walls and large objects
                        if (node.name && (
                            node.name.includes('Wall') ||
                            node.name.includes('Floor') ||
                            node.name.includes('Display_Stand') ||
                            node.name.includes('Sculpture') ||
                            node.name.includes('Bench')
                        )) {
                            const meshBox = new THREE.Box3().setFromObject(node);
                            if (cameraBox.intersectsBox(meshBox)) {
                                collision = true;
                                collisionCount++;
                                collidingMeshes.push(node.name || 'unnamed mesh');
                            }
                        }
                    }
                });

                // Debug logging
                if (collision) {
                    console.log('Collision detected!');
                    console.log('Number of collisions:', collisionCount);
                    console.log('Colliding with meshes:', collidingMeshes);
                    console.log('Attempted position:', newPos);
                    console.log('Current position:', camera.position);
                    console.log('Movement vector:', move);
                }

                if (!collision) {
                    camera.position.copy(newPos);
                } else {
                    // Try to slide along walls by preserving movement in non-colliding directions
                    const tryX = new THREE.Vector3(newPos.x, camera.position.y, camera.position.z);
                    const tryZ = new THREE.Vector3(camera.position.x, camera.position.y, newPos.z);
                    
                    // Check X movement
                    const cameraBoxX = new THREE.Box3();
                    cameraBoxX.setFromCenterAndSize(tryX, new THREE.Vector3(cameraSize, cameraSize, cameraSize));
                    let collisionX = false;
                    
                    // Check Z movement
                    const cameraBoxZ = new THREE.Box3();
                    cameraBoxZ.setFromCenterAndSize(tryZ, new THREE.Vector3(cameraSize, cameraSize, cameraSize));
                    let collisionZ = false;
                    
                    model.traverse((node) => {
                        if (node.isMesh) {
                            const meshBox = new THREE.Box3().setFromObject(node);
                            if (cameraBoxX.intersectsBox(meshBox)) collisionX = true;
                            if (cameraBoxZ.intersectsBox(meshBox)) collisionZ = true;
                        }
                    });
                    
                    if (!collisionX) camera.position.setX(tryX.x);
                    if (!collisionZ) camera.position.setZ(tryZ.z);
                }
            } else {
                camera.position.copy(newPos);
            }
        }

        // Function to load a GLB model
        function loadGLB(url) {
            if (model) {
                scene.remove(model);
                model.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (mat.map) mat.map.dispose();
                                    if (mat.lightMap) mat.lightMap.dispose();
                                    if (mat.aoMap) mat.aoMap.dispose();
                                    if (mat.emissiveMap) mat.emissiveMap.dispose();
                                    if (mat.bumpMap) mat.bumpMap.dispose();
                                    if (mat.normalMap) mat.normalMap.dispose();
                                    if (mat.displacementMap) mat.displacementMap.dispose();
                                    if (mat.roughnessMap) mat.roughnessMap.dispose();
                                    if (mat.metalnessMap) mat.metalnessMap.dispose();
                                    if (mat.alphaMap) mat.alphaMap.dispose();
                                    mat.dispose();
                                });
                            } else {
                                const mat = child.material;
                                if (mat.map) mat.map.dispose();
                                if (mat.lightMap) mat.lightMap.dispose();
                                if (mat.aoMap) mat.aoMap.dispose();
                                if (mat.emissiveMap) mat.emissiveMap.dispose();
                                if (mat.bumpMap) mat.bumpMap.dispose();
                                if (mat.normalMap) mat.normalMap.dispose();
                                if (mat.displacementMap) mat.displacementMap.dispose();
                                if (mat.roughnessMap) mat.roughnessMap.dispose();
                                if (mat.metalnessMap) mat.metalnessMap.dispose();
                                if (mat.alphaMap) mat.alphaMap.dispose();
                                mat.dispose();
                            }
                        }
                    }
                });
                console.log("Previous model removed and resources disposed.");
            }

            const loader = new GLTFLoader();
            loaderInfo.textContent = 'Loading model...';
            errorMessage.style.display = 'none';

            // Add draco decoder support for compressed models
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            loader.setDRACOLoader(dracoLoader);

            // Add KTX2 loader for more efficient textures
            const ktx2Loader = new KTX2Loader();
            ktx2Loader.setTranscoderPath('https://unpkg.com/three@0.153.0/examples/jsm/libs/basis/');
            ktx2Loader.detectSupport(renderer);
            loader.setKTX2Loader(ktx2Loader);

            // Add mesh optimizer for better performance
            loader.setMeshoptDecoder(MeshoptDecoder);

            loader.load(
                url,
                function (gltf) {
                    model = gltf.scene;
                    console.log("GLTF loaded successfully. Original model data:", gltf);
                    
                    // Preserve original materials and textures
                    model.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            
                            if (node.material) {
                                // Ensure proper color space for PBR materials
                                if (node.material.map) node.material.map.colorSpace = THREE.SRGBColorSpace;
                                if (node.material.emissiveMap) node.material.emissiveMap.colorSpace = THREE.SRGBColorSpace;
                                
                                // Preserve original material settings
                                node.material.envMapIntensity = node.material.envMapIntensity || 1.0;
                                node.material.needsUpdate = true;
                            }
                        }
                    });

                    // Add model to scene without modifying position or scale
                    scene.add(model);
                    loaderInfo.textContent = 'Model loaded successfully!';

                    // Add environment map for better PBR rendering
                    const pmremGenerator = new THREE.PMREMGenerator(renderer);
                    const envTexture = pmremGenerator.fromScene(new RoomEnvironment(renderer), 0.04).texture;
                    scene.environment = envTexture;
                    pmremGenerator.dispose();

                    console.log("Original model position:", model.position.clone());
                    console.log("Original model scale:", model.scale.clone());

                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    console.log("Model bounding box raw size:", size.clone());
                    console.log("Model bounding box raw center:", center.clone());

                    // Center the model at the origin
                    model.position.sub(center);
                    console.log("Model position after centering:", model.position.clone());

                    // Auto-scale model
                    const maxDim = Math.max(size.x, size.y, size.z);
                    let scaleFactor = 1.0; // Default scale
                    if (maxDim > 0.00001 && isFinite(maxDim)) {
                        scaleFactor = 5 / maxDim;
                        model.scale.setScalar(scaleFactor);
                        console.log("Applied scale factor:", scaleFactor, " (based on maxDim:", maxDim, ")");
                    } else {
                        console.warn("Could not calculate valid scale factor. maxDim:", maxDim, ". Using default scale 1.0.");
                        model.scale.setScalar(1.0);
                    }
                    console.log("Model scale after scaling:", model.scale.clone());

                    // Enable shadows and update materials
                    model.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (node.material) {
                                if (node.material.map) node.material.map.colorSpace = THREE.SRGBColorSpace;
                                node.material.needsUpdate = true;
                            }
                        }
                        if (node.isLight) {
                            node.intensity = 3;
                            console.log('Model contains a light:', node);
                        }
                    });

                    scene.add(model);
                    loaderInfo.textContent = 'Model loaded successfully!';
                    console.log("Model added to scene. Final position:", model.position.clone(), "Final scale:", model.scale.clone());

                    // Adjust camera to view the model
                    const finalBox = new THREE.Box3().setFromObject(model);
                    const finalSize = finalBox.getSize(new THREE.Vector3());
                    const finalCenter = finalBox.getCenter(new THREE.Vector3());

                    console.log("Final model box size:", finalSize.clone());
                    console.log("Final model box center:", finalCenter.clone());


                    // Set controls target and camera position to user-specified starting view
                    controls.target.set(4.089425786817376, -2.5246499558642443, 
                    40.85215282367115);
                    camera.position.set(3.4851652041292187, -2.500573032941849, 40.87994022312445); // <-- Set your desired starting camera position here
                    camera.lookAt(controls.target);
                    controls.update();

                    // Remove auto camera positioning logic, always use user-specified starting position

                    camera.lookAt(finalCenter);
                    controls.update();
                    console.log("Camera position:", camera.position.clone(), "Controls target:", controls.target.clone());

                    // --- Add a black plane above the ceiling panels to cover the gaps ---
                    // Find the bounding box of all SM_Drop_Ceiling panels
                    let ceilingMin = new THREE.Vector3(Infinity, Infinity, Infinity);
                    let ceilingMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
                    model.traverse((node) => {
                        if (node.isMesh && node.name.startsWith('SM_Drop_Ceiling')) {
                            node.updateWorldMatrix(true, false);
                            const box = new THREE.Box3().setFromObject(node);
                            ceilingMin.min(box.min);
                            ceilingMax.max(box.max);
                        }
                    });
                    // Only add the plane if we found at least one panel
                    if (ceilingMin.x < ceilingMax.x && ceilingMin.y < ceilingMax.y && ceilingMin.z < ceilingMax.z) {
                        const width = ceilingMax.x - ceilingMin.x + 0.1;
                        const depth = ceilingMax.z - ceilingMin.z + 0.1;
                        const y = ceilingMax.y + 0.01; // Slightly above the panels
                        const geometry = new THREE.PlaneGeometry(width, depth);
                        const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
                        const blackPlane = new THREE.Mesh(geometry, material);
                        blackPlane.position.set(
                            (ceilingMin.x + ceilingMax.x) / 2,
                            y,
                            (ceilingMin.z + ceilingMax.z) / 2
                        );
                        blackPlane.rotation.x = -Math.PI / 2; // Make it horizontal
                        blackPlane.renderOrder = -1; // Render below the panels
                        scene.add(blackPlane);
                    }
                },
                function (xhr) {
                    if (xhr.lengthComputable) {
                        const percentComplete = (xhr.loaded / xhr.total) * 100;
                        loaderInfo.textContent = `Loading: ${Math.round(percentComplete)}%`;
                    }
                },
                function (error) {
                    console.error('An error happened during loading:', error);
                    loaderInfo.textContent = 'Error loading model.';
                    errorMessage.textContent = 'Failed to load GLB file. Please ensure it is a valid .glb file. Check console for details.';
                    errorMessage.style.display = 'block';
                }
            );
        }



        // Enable first-person controls by default
        fpControls.enabled = true;

        // Add default model URL
        const DEFAULT_MODEL_URL = 'Art_Gallery.glb';

        // Initialize the scene on window load
        window.addEventListener('load', () => {
            enableFirstPersonControls(true);
            loadGLB(DEFAULT_MODEL_URL);
        });

        // Initialize the scene
        init();
    </script>
</body>
</html>